<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 中的常用命令</title>
      <link href="/2022/07/31/Linux%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/31/Linux%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>你渴望力量吗？</p><span id="more"></span><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>文件和目录的检视操作。</p><p>常用参数：</p><ul><li><code>-a</code>：列出全部文件</li><li><code>-d</code>：仅列出目录</li><li><code>-l</code>：列出文件权限与属性等</li><li><code>-S</code>：按文件容量大小排序</li><li><code>-i</code>：查阅 inode</li><li><code>--time=atime, ctime, mtime</code>：按不同时间显示</li></ul><table><thead><tr><th>简名</th><th>全名</th><th>中文名</th><th>含义</th></tr></thead><tbody><tr><td> atime</td><td>access time</td><td> 访问时间</td><td>文件中的数据库最后被访问的时间</td></tr><tr><td> mtime</td><td>modify time</td><td> 修改时间</td><td>文件内容被修改的最后时间</td></tr><tr><td> ctime</td><td>change time</td><td> 变化时间</td><td>文件的元数据发生变化。比如权限，所有者等</td></tr></tbody></table><h1 id="cp-rm-mv"><a href="#cp-rm-mv" class="headerlink" title="cp, rm, mv"></a>cp, rm, mv</h1><p>文件操作三巨头：复制、删除、移动</p><p>cp 常用参数：</p><ul><li><code>-a</code>：=<code>-dr --preserve=all</code>，保留所有权限、SELinux 属性、links、xattr 进行复制</li><li><code>-i</code>：覆盖前先询问</li><li><code>-p</code>：备份常用，连带文件属性（权限、用户、时间）复制过去，它的上位版是 <code>--preserve=all</code></li><li><code>-r</code>：递归复制，用于复制目录</li><li><code>-d</code>：复制链接（否则复制链接文件本身）</li><li><code>-l/-s</code>：复制为硬链接 / 软链接</li></ul><h1 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h1><h2 id="cat-x2F-tac"><a href="#cat-x2F-tac" class="headerlink" title="cat/tac"></a>cat/tac</h2><p>正向 / 反向打印一个文件。</p><p>常用参数：</p><ul><li><code>-n</code>：显示行号</li><li><code>-A(=-veT)</code>：可视化显示特殊字符</li></ul><h2 id="more-x2F-less"><a href="#more-x2F-less" class="headerlink" title="more/less"></a>more/less</h2><p>more：一次一页翻动，并且可以搜索</p><ul><li>空格键：向下翻一页</li><li> Enter：向下翻一行</li><li> b：向上翻一页</li><li>可以用 / 进行搜索</li></ul><p>less： 在 more 基础上可以使用 PgUp 和 PgDn，并且可以使用？向上搜寻</p><ul><li>g 或 G：前往第一行 / 最后一行</li><li> n 或 N：重复 / 反向重复上一个搜寻</li></ul><h2 id="head-x2F-tail"><a href="#head-x2F-tail" class="headerlink" title="head/tail"></a>head/tail</h2><p>从文件头 / 尾取内容。</p><p>公用参数：</p><ul><li><code>-n</code>：显示多少行内容<ul><li>负数表示：文件最后（head）/ 文件最前（tail）的 x 行不计入，即反向选择</li></ul></li><li><code>tail -f filename</code> 可以持续监控文件内容追加，很常用</li></ul><h2 id="od"><a href="#od" class="headerlink" title="od"></a>od</h2><p>二进制显示文件内容（不常用），自行参阅 man</p><h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p>修改文件访问时间 / 新建空白文件。</p><p>默认使用时，会同时修改 atime 和 mtime；可以使用开关设置行为。</p><h1 id="文件-x2F-目录权限设定"><a href="#文件-x2F-目录权限设定" class="headerlink" title="文件/目录权限设定"></a>文件 / 目录权限设定</h1><p>基本权限：-rwxrwxr-x</p><blockquote><p>目录的 w：修改文件表之权力（新增、删除、移动文件）</p><p>目录的 r：查阅文件表之权力（ls、自动补全）</p><p>目录的 x：进入目录之权力（cd、访问目录内文件）</p></blockquote><p>特殊权限：SetUID / SetGID / StickyBit</p><p>隐藏属性：chattr /lsattr</p><h2 id="基本权限"><a href="#基本权限" class="headerlink" title="基本权限"></a>基本权限</h2><p>改变所属群组：<code>chgrp GROUP file</code></p><p>改变文件拥有者：<code>chown USER:GROUP file</code></p><p>改变文件权限：</p><ul><li><p>八进制表示法（4 读 2 写 1 可执行）</p></li><li><p>字面表示法：</p><ul><li>u, g, o 表示三种身份，a 表示所有身份</li><li> r, w, x 表示三种权限</li><li> +, -, = 表示对权限的操作</li><li>例如：<code>chmod u=rwx, go=rx file</code></li><li>例如 2：<code>chmod u+x file</code></li></ul></li></ul><p>文件默认权限由 <code>umask</code> 设定，使用 <code>umask</code> 或 <code>umask -S</code> 来检视</p><blockquote><p>umask 指的是<strong>要去除</strong>的权限，从 666（文件）或 777（目录）中减去才是默认权限</p></blockquote><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID：对于<strong>可执行文件</strong>，执行此文件时执行者将在本程序中暂时获得程序 owner 的权限（owner 的 x 变为 s）</p><p>SGID：对于<strong>目录或可执行文件</strong>（group 的 x 变为 s）</p><ul><li>目录：用户在目录下新建的文件所属群组将与该目录群组相同</li><li>可执行文件：执行者在执行过程中获得该群组的支持</li></ul><p>SBit：对于<strong>目录</strong>（others 的 x 变为 t），群组用户或其他人<strong>具有 w, x 权限</strong>时，创建的文件和目录只有自己和 root 可以删除</p><h3 id="添加特殊权限"><a href="#添加特殊权限" class="headerlink" title="添加特殊权限"></a>添加特殊权限</h3><ul><li>八进制表示法：4（SUID），2（SGID），1（SBIT），放在原三位八进制前面</li><li>字面表示法：u+s, g+s, o+t</li></ul><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p>使用 <code>chattr</code> 设置，<code>lsattr</code> 查看的特殊属性</p><p>常用属性：</p><ul><li>a：文件只能追加，不能删除和修改（常用于日志）</li><li>i：文件锁定，无法删除、改名、链接、写入、追加</li><li> A：访问时不修改 <code>atime</code></li><li>S：确保改动同步写入磁盘，关闭 sync</li></ul><h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><p>搜索可执行文件：<code>which</code></p><p>搜索特定目录下文件：<code>whereis</code>（<code>whereis -l</code> 查看位置）</p><h2 id="搜索全部文件"><a href="#搜索全部文件" class="headerlink" title="搜索全部文件"></a>搜索全部文件</h2><ul><li>locate：依照数据库寻找文件<ul><li>常用参数：<code>-c</code>（计数），<code>-l</code>（限制数量）</li><li>使用 <code>updatedb</code> 更新数据库，一般是一天自动更新</li></ul></li><li> find：根据条件全盘搜索</li></ul><h3 id="find：在某目录下进行高级搜索"><a href="#find：在某目录下进行高级搜索" class="headerlink" title="find：在某目录下进行高级搜索"></a>find：在某目录下进行高级搜索</h3><p><code>find [PATH] [option] [action]</code></p><p>它有很多高级用法和限定条件，示例如下：</p><h4 id="时间搜索"><a href="#时间搜索" class="headerlink" title="时间搜索"></a>时间搜索</h4><ul><li><code>-atime, -ctime, -mtime n</code>，n 表示 <strong>n 天前</strong>的<strong>一天之内</strong></li><li>可以使用 <code>+n -n</code> 表示大于等于 n 天前、小于等于 n 天内</li><li><code>find /var -mtime -4</code></li></ul><h4 id="用户和用户组搜索"><a href="#用户和用户组搜索" class="headerlink" title="用户和用户组搜索"></a>用户和用户组搜索</h4><ul><li><code>-uid n</code> 和 <code>-user name</code>：指定拥有者搜索</li><li><code>-gid n</code> 和 <code>-group name</code>：指定拥有群组搜索</li><li><code>-nouser</code> 和 <code>-nogroup</code>：无用户或群组（源码安装的程序、灵魂用户）</li></ul><h4 id="文件属性搜索"><a href="#文件属性搜索" class="headerlink" title="文件属性搜索"></a>文件属性搜索</h4><ul><li><code>-name filename</code>：文件名搜索</li><li><code>-size [+-]SIZE</code>：大小搜索（单位：c - 字节，k-KB）</li><li><code>-type fbcdlsp</code>：类型搜索</li><li><code>-perm 4755</code>：权限搜索<ul><li><code>-perm -4755</code>：必须囊括全部 mode（大于等于）</li><li><code>-perm /4755</code>：具有任一 mode 权限（小于等于）</li></ul></li></ul><h4 id="条件组合"><a href="#条件组合" class="headerlink" title="条件组合"></a>条件组合</h4><p>使用 <code>-and / -a</code>、<code>-or / -o</code>、<code>-not / !</code> 进行条件组合</p><pre><code class="bash"># 寻找/etc目录下，大于50k小于60k的文件，并列表显示find /etc -size +50k -and -size -60k -exec ls -l {} \;# 寻找/etc目录下，大于50k且所属人不是root的文件，并列表显示find /etc -size +50k -and -not -user root -exec ls -l {} \;</code></pre><h4 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h4><ul><li><code>-exec command</code>：将查找到的文件传递给指定命令 </li></ul><pre><code class="bash">find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} \;</code></pre><p>exec 之后的块中使用 {} 替换变量，使用 <code>\;</code> 结束 exec 块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于友链的中文独立博客发现</title>
      <link href="/2022/07/16/%E5%9F%BA%E4%BA%8E%E5%8F%8B%E9%93%BE%E7%9A%84%E4%B8%AD%E6%96%87%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0/"/>
      <url>/2022/07/16/%E5%9F%BA%E4%BA%8E%E5%8F%8B%E9%93%BE%E7%9A%84%E4%B8%AD%E6%96%87%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>怎么大家都有朋友.jpg</p><span id="more"></span><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>2022 年某天晚上我突发奇想：</p><p>已知很多博客都有友链，它们之间常常呈交叉链接关系。那么，如果我能编写一只自动追踪友链的爬虫，沿着友链不断递归前进，最后能否穷尽所有（有友链的）中文独立博客？</p><p>这个需求从爬虫的角度来看其实十分简单。待爬取链接全都是首页，无需解析复杂的数据结构，大部分目标为静态网站，并且几乎没有反爬措施。真正的难点在于非工程的部分：怎样判断一个链接是不是博客，且如何获取它的友链？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个程序的思路十分原始且暴力。</p><p>从 x 个带有友链的博客开始：</p><ol><li>读取首页和 Sitemap，寻找可能为友链的页面链接。</li><li>读取友链页面，提取出页面中所有的外站链接。</li><li>简单地认为这些外站链接都是潜在的博客，重复 1。</li></ol><p>1 的判断标准其实还挺简单，最后定格为如下条件：</p><pre><code class="python"># 检查URL和链入标题, 是否包含特定关键词links_keyword = ['friend', 'link']title_keyword = ['友情链接', '友链', '朋友', '友人', 'Friend']</code></pre><p>2 也没有太大难度，过滤一下 <code>domain</code> 和本家相同的就可以。</p><p>小步快跑、快速迭代一向是我的特长，这种级别的需求我一般可以在几小时内给出解决方案，但代价绝对是可维护性为 0… 这次也不例外。</p><h2 id="一如既往地编写Shit"><a href="#一如既往地编写Shit" class="headerlink" title="一如既往地编写Shit"></a>一如既往地编写 Shit</h2><p>编写第一版程序的时候低估了工作量，没有使用 ORM 和爬虫框架，采用 sqlite3 和 pyppeteer 爆肝一下午纯天然手工编写而成。为此自己给数据建了模，还写了一大堆数据库测试，头发数量减少（不是很难，但恶心）。</p><p>然而在扩展时发现第一版实现的 <code>Url</code> 和 <code>Blog</code> 类型存在重大缺陷，设计上考虑不周导致类型混乱，<code>blog.Url.url_str</code> 这种类型不明的屎满天飞。此外，数据库保存的是 URL 而非域名，因此同一个域的不同 path 会被多次计入，<code>http</code> 和 <code>https</code> 也会被当作两个条目分别保存。项目结构很水，无力修改，再加上天生单线程，于是最终作废，光荣进入垃圾堆。</p><p>你可以在<a href="https://git.amono.me/AsterisMono/Influnc">这里</a>找到第一版程序。</p><h2 id="草鸡涅槃"><a href="#草鸡涅槃" class="headerlink" title="草鸡涅槃"></a>草鸡涅槃</h2><p>第二版开始设计的时候吸取了第一版的教训，在保持数据库结构简洁的同时，选择保存博客域名而非地址（方便查重，但是对不起那些形如 <code>www.myspace.com/blog</code> 的同学）。从第一版数据的分析结果中，还总结出了一个博客条目的几种状态：在线（友链）、在线（无友链）、离线。</p><p>这次学乖了，人生苦短，我用框架。ORM 选用了 <a href="https://github.com/coleifer/peewee">peewee</a>，爬虫框架当然是大名鼎鼎的 <a href="https://github.com/scrapy/scrapy">scrapy</a>，边玩边学，寓教于乐。</p><p>最终代码质量我觉得（相对我以前写的屎来说）还算可以，开箱即用，内置几个过滤组件和数据库；你可以在<a href="https://github.com/AsterisMono/InfluncPlus">这里（GIthub）</a>或<a href="https://git.amono.me/AsterisMono/InfluncPlus">这里（Gitea）</a>找到第二版代码，欢迎 Star。</p><h2 id="爬取过程与数据过滤"><a href="#爬取过程与数据过滤" class="headerlink" title="爬取过程与数据过滤"></a>爬取过程与数据过滤</h2><p>世事无常，大肠包小肠。</p><p>在不断迭代爬取数据的过程中，我收获了包括且不限于如下惊喜：</p><p>xx 人才网 where xx in 中国城市列表；化学材料网、螺管螺帽网；麦片站群和他的爹地赌狗站；软件园、下载站；各种在线离线无米线站长工具、签到工具、下载工具、百度云解析、阿里云列表、网易云音乐解锁；各种官网（云服务、Vultr、Hexo、Cloudflare，甚至学习强国）；各种商业网站（SEO、图库、垃圾站群、养生、证券）；私人云盘、私人图床还有小姐姐。</p><p>而且更残酷的事实是，这些站普遍都很重道义地挂了友情链接，也就是说 引一匹狼入数据库 = 狼均引流狗 = 大面积数据污染。讲真我非常好奇这些链接最终追溯回去是哪位老哥引流进来的（虽然最后也没查）…</p><p>因为我有一边爬一边盯着数据库看的习惯，所以发现还算及时。第一批被发现的是 xx 人才网，应对方案也很简单，写一个屏蔽词列表，加入一个 <code>FilterPipeline</code> 把 <code>title</code> 看起来不对的条目丢弃就可以。</p><p>首先荣登黑名单的是全国各大城市名称和省份名称（对不起把自己的定位写在标题里的同学们，你们被无情抛弃惹）。然后是一些常见单词，和一些常见但不能写在这里的单词。在不断爬取 - 检查 - 丰富名单 - 重新开始的过程中，屏蔽词不断发展壮大，最终条目数量居然达到了 500 左右。这个数目如果还写成 <code>list</code>，每个条目都会遍历一次 <code>list</code>，然后每个 <code>list</code> 中的条目都要做一次字符串匹配，感觉代价有一点不可接受，遂咕果，寻找更好的方案。</p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC 自动机</h2><p>咕果指路：<a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm">ahocorasick</a>。</p><p>简单了解了一下，AC 自动机能在字符串中快速匹配字典中的字串… 那就决定是它了。</p><p>Stackoverflow 拼凑之，弄出一只单例 <code>Tester()</code>，在爬虫内外大肆使用。为了调试方便还实现了一个屏蔽词热更新功能：当爬取过程中检测到屏蔽词库发生变化时，会自动重载词库并重新生成自动机，造福人类。</p><h2 id="禁止超速行驶"><a href="#禁止超速行驶" class="headerlink" title="禁止超速行驶"></a>禁止超速行驶</h2><p>爬取过程中遇到两个非常搞笑的 BUG。</p><p>第一，数据库最开始有两个条目，理论上会从这两个条目派生出至少 50 条，然后系统就可以全速并行爬取。但是这玩意和冬天的老爷车犯同一个毛病：第一次打火，不一会就熄火，得多打两次才能启动。</p><p>一顿头脑风暴后发现，提供待爬取条目的函数长这样：</p><pre><code class="python">def start_requests(self):    cleanup_database()    while has_unaccessed_blog():        blog = get_unaccessed_blog()        blog.status = "pending"        blog.save()        url = "https://" + blog.domain        yield scrapy.Request(url, callback=self.parse_blog, errback=self.error_handling, cb_kwargs={'src': blog})</code></pre><p>注意那个 <code>while</code>。在初始条目较少的情况下，它们会很快地被 <code>yield</code> 出去，然后这个函数就会因为 <code>has_unaccessed_blog == False</code> 而退出，后续添加进来的条目也就没有办法被看到。</p><p>解决方案是？当然是不解决。预热一次左右就可以全速爬取，无非是多点一下鼠标的事情。</p><p>第二，有些人的博客首页不太规范。这个程序不知什么原因，遇到首页 SSL 证书货不对板、或者无限重定向的情况，那个爬取线程就会不声不响的退出，在数据库里留下来一个 <code>pending</code> 的烂摊子，有时候还会导致整个爬取进程都卡住不动。这个我也没有找到很好的解决方案（DEBUG 日志都不会输出，怀疑是内部 Bug），只能在最后爬虫收敛的时候手动在数据库里进行标记。</p><h2 id="收敛"><a href="#收敛" class="headerlink" title="收敛"></a>收敛</h2><p>这个其实在我的意料之中，博客条目们最终一定会收敛成一个类似离散数学中群的东西，任何一个条目的所有友链都存在于这个数据库，也就不再会有新的条目。</p><p>经过机器过滤和人工过滤后，总条目数定格在 12474 条。其中在线 7116 条（含友链 3920 条，不含友链 3196 条），离线 4246 条，其余被标记删除。</p><p>粗略翻看了一下，个人认为准确率相当不错，在翻看途中也发现了很多自己平时就经常拜访的博客，感觉十分奇妙。这份数据除了当作订阅列表外，因其保存了博客之间的友链关系，还具有潜在的科研价值。</p><p>由于潜在的侵权和法律相关问题，我最终决定还是不公开得到的数据库。但由于短时间内大家的友链不太可能发生改变，想要同款数据的同学可以下载源码自行爬取，开袋即食。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 中的智能指针</title>
      <link href="/2022/07/16/Rust%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/07/16/Rust%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>This is next level shit…</p><span id="more"></span><h1 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h1><p>最简单的智能指针，里面包含一个指向堆上数据的指针。</p><pre><code class="rust">let box = Box::new(5);</code></pre><h1 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h1><p>包含强引用计数的智能指针，可以使用 <code>Rc::clone</code> 进行复制。</p><pre><code class="rust">let rc_box = Rc::new(5);println!("Value: {}", *rc_box);         // deref to i32, or any other type without refprintln!("Reference counter: {}", Rc::strong_count(&amp;rc_box));let rc1 = Rc::new(String::from("Rc"));let deref_rc1 = *rc1;                   // Panics; Can not move String out of owner rclet deref_rc1_ref = &amp;*rc1               // &amp;Stringlet rc2 = Rc::clone(&amp;rc1);              // Rc&lt;String&gt;rc2.push_str("string");                 // Panics; Can not modify Rc, DerefMut not implemented</code></pre><h1 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h1><p>支持 “内部可变性模式”。可以在运行时创造内部数据的 <code>borrow</code> 或 <code>mut borrow</code> 并进行所有权检查。</p><pre><code class="rust">let refcell = RefCell::new(String::from("RefCell"));let refcell_string = refcell.borrow();               // Ref&lt;String&gt;let refcell_string_deref = *refcell.borrow();        // Panics; Can not move String out of Reflet mut refcell_string = refcell.borrow_mut();       // MutRef&lt;String&gt;refcell_string.push_str("string");</code></pre><h1 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h1><p>弱引用；当强引用计数归零时，数据被销毁，弱引用会返回 <code>None</code>。</p><p>使用 <code>Rc::downgrade(Rc&lt;T&gt;)</code> 创建，<code>Weak::upgrade()</code> 获取 Rc。</p><pre><code class="rust">#[derive(Debug)]struct Node {    value: i32,    next: RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;,    prev: RefCell&lt;Option&lt;Weak&lt;Node&gt;&gt;&gt;,}let node1 = Rc::new(Node {    value: 1,    next: RefCell::new(None),    prev: RefCell::new(None),});let node2 = Rc::new(Node {    value: 2,    next: RefCell::new(Some(Rc::clone(&amp;node1))),    prev: RefCell::new(None),});*node1.prev.borrow_mut() = Some(Rc::downgrade(&amp;node2));println!("{:#?}", node1);println!("{:#?}", node2);let parent_value = node1 // Rc&lt;Node&gt;    .prev          // Auto deref, RefCell&lt;Option&lt;Weak&lt;Node&gt;&gt;&gt;    .borrow()      // Ref&lt;Option&lt;Weak&lt;Node&gt;&gt;&gt;, also as &amp;Option&lt;Weak&lt;Node&gt;&gt;&gt;    .as_ref()      // Option&lt;&amp;Weak&lt;Node&gt;&gt;, prevent moving Option&lt;Weak&lt;Node&gt;&gt; out of Ref    .unwrap()      // &amp;Weak&lt;Node&gt;    .upgrade()     // Option&lt;Rc&lt;Node&gt;&gt;，upgrade(&amp;Weak&lt;T&gt;) -&gt; Option&lt;Rc&lt;T&gt;&gt;    .unwrap()      // Rc&lt;Node&gt;    .value         // Auto deref to Node.value, i32</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Docker 部署 Jenkins 并构建、测试、部署 Django 项目</title>
      <link href="/2022/04/13/%E4%BD%BF%E7%94%A8-Docker-%E9%83%A8%E7%BD%B2-Jenkins-%E5%B9%B6%E6%9E%84%E5%BB%BA%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E9%83%A8%E7%BD%B2-Django-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/13/%E4%BD%BF%E7%94%A8-Docker-%E9%83%A8%E7%BD%B2-Jenkins-%E5%B9%B6%E6%9E%84%E5%BB%BA%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E9%83%A8%E7%BD%B2-Django-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>Buff 叠满了属于是</p><span id="more"></span><h2 id="Prerequisite：部署-Jenkins"><a href="#Prerequisite：部署-Jenkins" class="headerlink" title="Prerequisite：部署 Jenkins"></a>Prerequisite：部署 Jenkins</h2><p>我其实很不喜欢写安装 / 部署一个公共服务的过程，因为感觉按部就班操作没啥写的，看别人写博客都特喜欢一步一步把 Installation Guide 抄一遍，带上在自己服务器上 bling bling 的截图，可是有啥意义呢？个人感觉很浪费宝贵的学习时间啊 = = ， 这里略了。</p><p>Jenkins 官网推荐的第一种安装方式就是使用 Docker，同时也注明了 “可能需要一些小调整”，但再难不过改一改 Dockerfile，和手动安装比起来还是方便许多。</p><p>可是我那时（指写下这篇文章的前天晚上）还 too young too naive，不知道 Docker 赠送的礼物，早已在暗中标好了价格～</p><h2 id="Jenkins-in-Docker-带来的一些后果"><a href="#Jenkins-in-Docker-带来的一些后果" class="headerlink" title="Jenkins in Docker 带来的一些后果"></a>Jenkins in Docker 带来的一些后果</h2><p><strong>不能使用主机的工具链！</strong></p><p>对 Python 这种非开袋即食、也不提供编译环境 Docker 镜像、依赖还要靠半自动安装的语言，不能使用本地工具链就等于不能编译。Java 人家有 maven 镜像，咱们有啥啊？Python 都给你扬咯，<code>/usr/bin/</code> 里啥也不剩，干净得很。</p><p>此外，Jenkins 自身对 Python 也不是那么友好，ShiningPanda 插件最新版发布于四年前，Pyenv Pipeline 插件最新版也是三年前的老古董，StackOverflow 上说甚至难以保证正常使用，想了想还是算了，咱不受这气，自己装一个吧…</p><h2 id="配置-Dockerfile"><a href="#配置-Dockerfile" class="headerlink" title="配置 Dockerfile"></a>配置 Dockerfile</h2><p>配置工作很简单，加上三层 RUN 层，如下：</p><pre><code># 安装编译工具链RUN apt-get -y install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev# 拉取 Python 源码并编译RUN wget https://www.python.org/ftp/python/3.10.4/Python-3.10.4.tgz &amp;&amp; tar -xf Python-3.10.*.tgz &amp;&amp; cd Python-3.10.*/ &amp;&amp; ./configure --enable-optimizations &amp;&amp; make -j 4 &amp;&amp; make install# 安装 pip &amp; 安装 virtualenvRUN python3 -m ensurepip --upgrade &amp;&amp; python3 -m pip install virtualenv</code></pre><p>这里我们只安装 <code>python</code> 和 <code>virtualenv</code>，具体的依赖包会在 Jenkins 里面详细配置，不过如果有想全局安装的包也可以放到这里，构建时可以做 venv 的 pip 缓存用。</p><p>修改好 Dockerfile 后，打 tag 构建镜像：</p><pre><code>docker build -t jenkins-py310:1.0</code></pre><p>在 1c2g 的小鸡上构建 Python3.10 大约花了 20 分钟，速度还可以接受。更重要的是，这样排布的 Dockerfile 里，第一层和第二层都是可重用的；如果日后要修改 Python 版本或者修改全局安装的 Python 包，可以节省一点时间（如果能复用第二层就是节省大量时间！）</p><h2 id="配置-Jenkins-进行基本-Django-测试"><a href="#配置-Jenkins-进行基本-Django-测试" class="headerlink" title="配置 Jenkins 进行基本 Django 测试"></a>配置 Jenkins 进行基本 Django 测试</h2><p>建立一个 Free Style Jenkins 项目，配置其使用 <code>mysite</code> 仓库，并编写构建脚本。</p><p>在 <a href="https://stackoverflow.com/questions/21103727/how-to-tell-jenkins-to-use-a-particular-virtualenv-python">这里</a> 找到了一小段激活 <code>virtualenv</code> 的脚本，我做了一点修改：</p><pre><code>#/bin/bash# This fails miserably and I don't know why# set -euox pipefail# Get an unique venv folder to using *inside* workspace# Uncomment the following line for parallel build# VENV=".venv-$BUILD_NUMBER"VENV=".venv"# Initialize new venvvirtualenv "$VENV"# Update pipPS1="${PS1:-}" source "$VENV/bin/activate"# &lt;YOUR CODE HERE&gt;pip install -r requirements.txtpython manage.py test</code></pre><p>现在执行构建，应该能看到构建成功了，控制台输出会打印出测试日志。</p><p><img src="/images/success_django_test.png"></p><p>同样的，当测试失败的时候，对应的构建也会直接 Fail。</p><h2 id="Jenkinsfile-与-Pipeline"><a href="#Jenkinsfile-与-Pipeline" class="headerlink" title="Jenkinsfile 与 Pipeline"></a>Jenkinsfile 与 Pipeline</h2><p>上面的测试构建在现实中几乎没有任何意义，只不过是把 <code>manage.py test</code> 挪到了 Jenkins 服务器上运行而已。对于更加实际的应用来说，在开发中引入 CI，主要是为了实现以下这个流程的自动化：</p><blockquote><p>commit - 测试 - 打包 - 部署</p></blockquote><p>其中，如果测试环节能生成一份美观的测试报告，那就更好了！如果测试失败，最好让整个流程停下来并发出警告，避免不能通过测试的版本被部署上线。</p><p>根据 <a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/">Jenkinsfile</a> 的解说，我们可以在仓库根目录编写一个 <code>Jenkinsfile</code>，采用它声明式的语法来定义每个运行流程，形成一个 <code>Pipeline</code> 任务。</p><p>这样做有诸多好处：</p><ul><li><code>Jenkinsfile</code> 可以像普通代码一样被修改、commit、review。</li><li>不需要进入 Jenkins 配置面板就可以修改构建流程</li><li>构建配置和代码存放在同一仓库，避免配置分散化</li></ul><p>本项目的构建流程分为以下三步：安装依赖，测试，部署上线。据此编写的 <code>Jenkinsfile</code> 位于这里：<a href="https://git.amono.me/AsterisMono/mysite/src/commit/83fdc7fbef446cc23da7645ae9fb577f47dd0b42/Jenkinsfile">mysite/Jenkinsfile</a></p><p>因为这篇文章使用的是测试项目，所以在这里略去部署环节，改天等我 Django 修为大成再填补进来：D</p><h2 id="收集测试报告"><a href="#收集测试报告" class="headerlink" title="收集测试报告"></a>收集测试报告</h2><p>默认情况下，Django 测试结果仅在命令行输出，如果测试一多起来，想快速定位失败的测试非常困难，而且也非常辣眼睛。</p><p>Jenkins 可以收集并处理 xml 格式的测试报告，但是 Django 默认的测试框架并不支持此种输出，这里可以使用一个库 <a href="https://github.com/xmlrunner/unittest-xml-reporting">unittest-xml-reporting</a>。</p><p>安装后在 <code>settings.py</code> 中写入以下内容，并相应修改 <code>Jenkinsfile</code> 即可：</p><pre><code>TEST_RUNNER = 'xmlrunner.extra.djangotestrunner.XMLTestRunner'TEST_OUTPUT_DESCRIPTIONS = TrueTEST_OUTPUT_DIR = 'reports'TEST_OUTPUT_VERBOSE = 2</code></pre><p>这玩意看起来就好看多了！</p><p><img src="/images/jenkins_xunit_test.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 盒模型</title>
      <link href="/2022/01/13/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/01/13/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>ＣＳＳ　ＩＳ　ＡＷＥＳＯＭＥ</p><span id="more"></span><ul><li><p>块级盒子与内联盒子</p><ul><li><p>块级盒子：自动扩展到<strong>与父容器同宽</strong>，<strong>自动换行</strong>，有 <code>width</code> 和 <code>height</code></p></li><li><p>内联盒子：不会自动换行，<code>width</code> 和 <code>height</code><strong>不起作用</strong>，<strong>垂直方向</strong>的 <code>padding</code>、<code>margin</code>、<code>border</code><strong>不会推开其他盒子</strong></p></li></ul></li></ul><pre><code class="css">.class {  display: inline; /* inline, block, inline-block（不换行）, flex, inline-flex */}</code></pre><ul><li><p>内部与外部显示类型</p><ul><li>外部显示类型：<code>display</code> 指定</li><li>内部显示类型：盒子内部元素如何布局，默认是正常文档流；<code>display: flex</code> 使内部所有直接子元素成为 <code>flex</code> 元素</li></ul></li><li><p> Content Box</p><ul><li><code>width</code>、<code>height</code> 实际上指定的是 <code>content box</code> 大小，总元素大小需要加上 <code>margin</code>、<code>padding</code>、<code>border</code></li><li>替代盒模型：<code>width</code>、<code>height</code> 作为整体大小，<code>box-sizing: border-box</code></li></ul></li><li><p>Margin</p><ul><li>Margin 可以为负值；这会造成元素与其他元素重叠</li><li>外边距折叠：两个 <code>margin</code> 相接的元素，<code>margin</code> 将取最大值被合并</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结：AI-Crowdwork</title>
      <link href="/2022/01/12/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9AAI-Crowdwork/"/>
      <url>/2022/01/12/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%9AAI-Crowdwork/</url>
      
        <content type="html"><![CDATA[<p>学得越多，越认识到自己的无知</p><span id="more"></span><h2 id="这是一个什么样的项目？"><a href="#这是一个什么样的项目？" class="headerlink" title="这是一个什么样的项目？"></a>这是一个什么样的项目？</h2><p>受一直以来十分照顾我的学长委托，编写一个 AI 训练数据库的前端。</p><p>简而言之，它可以供用户浏览数据集里的图片和对应的文字描述；对于人脑觉得有问题的描述，它还需要列出图片对应的【属性】或者【描述字串】，给出输入框供用户进行修改。</p><p>功能很简单，应用面不大，需求明确，可以说是前端新手练习的好素材。</p><h2 id="设计的思路？"><a href="#设计的思路？" class="headerlink" title="设计的思路？"></a>设计的思路？</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>使用单页面应用的思路构建，一共三个路由（主页、图片浏览、数据修正）。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><ul><li>训练集数据以【对象】为单位进行组织。每个【对象】位于一张图片上，但是一张图片中可能含有多个【对象】。</li><li>每张图片对应一个 <code>xml</code> 格式的数据文件，内含图片信息和【对象】们的属性与描述。</li><li>【对象】有两种类型，通过数据文件中的 <code>useAttributeNum[6]</code> 属性进行区分。<ul><li>绝对定位对象：需要在修正页面中列出【基础属性】。</li><li>相对定位对象：只需在修正页面中列出【描述】。</li></ul></li><li>每个【对象】对应一个【目标框】，需要在图片上画出来，指示对象的位置。</li></ul><h3 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h3><p>这次前端部分选用了 <code>React</code>，一方面是想拓展自己的前端技术栈，把两大热门框架都尝试一遍，选择更适合自己的那一个；另一方面是一直以来都对 <code>React</code> 推崇的函数式编程很感兴趣，<code>Hooks</code> 推出之后更是可以完全抛弃类组件，用函数组件一把梭。</p><p>为了更快熟悉 <code>JavaScript</code> 的语言环境，后端使用 <code>Express</code> 框架， 没有使用我比较有经验的 <code>SpringBoot</code> 或者 <code>Django</code>。虽然也只是写业务罢了。..</p><h2 id="实现的过程？"><a href="#实现的过程？" class="headerlink" title="实现的过程？"></a>实现的过程？</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>因为这个项目比较小，我采取了先整体实现再拆分组件的自上而下策略。下次应该试试从组件开始设计。</p><p>主要的需求点是能够显示【对象】，即根据【图片 ID】和【对象 ID】，显示图片、目标框和描述文字。</p><p>构造出 <code>ImageView</code>（包括图片、目标框、文字、切换按钮）之后，注意到其中【对象显示】功能的独立性，这个组件可以在【数据修正】功能里复用，于是拆分出来，签名如下：</p><pre><code class="javascript">/*  props.imageID  props.objectID */export function ObjectViewer({ imageID, objectID, className }) {    ...}</code></pre><p>这样拆分的好处是，<code>Props</code> 含义明确，将从 API 获取图片和目标框的逻辑隐藏在组件内部，不需要在 <code>View</code> 中重复编写 API 代码。</p><p>然后，由于绘制【目标框】的需求，图片没法使用 <code>img</code> 标签显示啦，只能用 <code>Canvas</code> 绘制，而绘制图片和目标框的逻辑也比较复杂，所以拆分出 <code>ImageViewPort</code> 组件：</p><pre><code class="javascript">/*  props.src: Image source  props.box: Box position [x1, y1, x2, y2]  props.size: Canvas size [x, y] */export function ImageViewPort({ src, box, size }) {    ...}</code></pre><p>组件内部使用 <code>useEffect</code> 处理 <code>box</code> 的变化；因为 <code>Canvas</code> 的绘制是画家算法，所以即使只有 <code>box</code> 变动了，也需要重绘所有内容，以保持层级关系。</p><p>在写这个 <code>effect</code> 的时候，我和 <code>create-react-app</code> 自带的 <code>ESLint</code> 规则发生了一点小冲突。它觉得这个 <code>effect</code> 依赖 <code>src</code>、<code>box</code>、<code>size</code> 三个变量，任何一个发生变化，就应当刷新 <code>effect</code>；但我最后给依赖写成了 <code>[box]</code>，保证每次参数变动（<code>box</code> 一定变化）只刷新一次。</p><p>这个 <code>Lint</code> 的目的是防止开发者忘记写全依赖变量导致漏更新，但我在测试中发现，三个变量同时指定为依赖，会导致随机出现目标框不变的问题。由于图片会正常更新，而画家算法保证图片一定是先绘制的，目标框一定是后绘制的，所以可以确定是 <code>box</code> 出了什么问题。</p><p>第一直觉，<code>box</code> 是在 <code>image.onload</code> 回调中绘制的，拿到的是闭包中的旧 <code>box</code> 值？可理论上三个 <code>props</code> 参数应该是同时（原子）更新的。.. 只能猜测，在实际的执行过程中，<code>src</code>、<code>box</code>、<code>size</code> 的更新是分开的，并且可能发生抢占；当遇到 <code>src</code> 先更新的情况时，<code>effect</code> 刷新，这个闭包里 <code>box</code> 的值仍然是上一次绘制的 <code>box</code>。具体原因还是要抽时间看一下源码。</p><p>有了上面两个组件的构建经验，到构建 <code>ErrorCorrectionView</code> 和 <code>ObjectPropTable</code> 的时候，我已经有了一定的熟练度。</p><p><code>ErrorCorrectionView</code> 中涉及条件渲染，最开始的解决方案是根据 <code>mode</code> 的值返回不同组件，在实践中发现会造成 <code>objectViewer</code> 不必要的重复渲染；后来改用了这种实践，只涉及一个 <code>return</code>，不需要重新渲染 <code>objectViewer</code>。</p><pre><code class="javascript">return (  &lt;div    className={mode === "check" ? "" : "flex lg:flex-row sm:flex-col h-full"}  &gt;    {objectViewer}    {mode === "check" ? checkButton : editArea}  &lt;/div&gt;);</code></pre><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>如何优雅地给组件上样式一直是 <code>React</code> 中的老大难问题。这个项目里为了避免麻烦，直接使用了 <code>TailwindCSS</code>，但样式仍然不可避免地成为了组件化和组件重用的最大障碍。..</p><p>目前个人觉得比较方便的方案如下：</p><ul><li>组件内部样式（字体、颜色、<code>margin</code> 和 <code>padding</code>）直接写死在组件内部</li><li>每个组件的根 <code>&lt;div&gt;</code> 接收来自 <code>props</code> 的 <code>className</code>，方便重用时适配不同场景</li></ul><p>另外，我 CSS 基础还是很差，实现效果全靠猜和试，是时候系统学习一遍了 = =</p><h2 id="部署过程？"><a href="#部署过程？" class="headerlink" title="部署过程？"></a>部署过程？</h2><p>还没有部署，如果后续部署到服务器上会回来补这一段的</p><h2 id="总结与-Component-杂谈"><a href="#总结与-Component-杂谈" class="headerlink" title="总结与 Component 杂谈"></a>总结与 Component 杂谈</h2><p>写作过程中发现一个很值得思考的问题：</p><blockquote><p>在组件（Components，与 View 区分）中，是否应该限制<strong>业务</strong>相关 <code>State</code> 的使用？</p></blockquote><p>我的想法是：如果没有特殊需求，业务信息（API 数据等）其实不应该被放进 <code>Component</code> 的 <code>State</code>。</p><p>首先，数据流应当是自上而下传递的。如果一个 <code>Component</code> 包含某种业务数据，那么很可能存在以下两个事实：</p><ul><li>它的父 <code>View</code> 也包含同样的数据。</li><li>它的父 <code>View</code> 或兄弟 <code>Component</code> 也需要同样的数据。（如果现在没有，那么以后也很可能会发生。）</li></ul><p>第一种情况中，这样做相当于潜在声明，<code>Component</code> 可能会对数据做出更改，比如 <code>fetch</code> 新数据，或者按某个业务逻辑去编辑数据，会造成潜在的数据不同步；而第二种情况更糟，因为 <code>React</code> 并不提倡子组件给父组件传递信息。所以，你要么使用一串向上的 <code>Ref</code>，但那会破坏封装；要么使用 <code>Context</code> 或者状态，也不是什么好解决方案，尤其当项目很复杂时更是如此。或者，你也可以选择在父 <code>View</code> 中再写一份业务代码来获取这个数据，造成代码重复和一次额外的 API 访问。</p><p>所以，应该严格遵守以下原则：</p><ul><li>业务数据保存在 <code>View</code> 的 <code>State</code> 内</li><li>对于 <code>Component</code>，业务数据由 <code>props</code> 进，由 <code>updatePropCallback</code> 出，内部状态仅限于组件自身属性</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 教程速读笔记</title>
      <link href="/2021/12/07/React%E6%95%99%E7%A8%8B%E9%80%9F%E8%AF%BB/"/>
      <url>/2021/12/07/React%E6%95%99%E7%A8%8B%E9%80%9F%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>用一下午的时间速读了一下 React 的官方教程文档…</p><span id="more"></span><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><pre><code class="javascript">const element = &lt;h1&gt;Hello world!&lt;/h1&gt;;</code></pre><ul><li><p>JavaScript 的语法扩展</p></li><li><p>使用大括号 <code>{}</code> 放置 JavaScript 表达式</p></li><li><p>建议将内容包裹在括号中</p></li><li><p>本质是表达式</p><ul><li><p>编译时被转换为 JavaScript 函数调用并取值</p></li><li><p>结果是 JavaScript 对象 ： React 元素</p></li></ul></li></ul><h2 id="React-元素"><a href="#React-元素" class="headerlink" title="React 元素"></a>React 元素</h2><ul><li><p>与 DOM 元素区分：React 元素是普通对象，它被 ReactDOM 渲染为 DOM</p><pre><code class="javascript">ReactDOM.render(element, document.getElementByID('App'));</code></pre></li><li><p>React 元素<strong>不可变</strong>，就像游戏的一帧，代表某个时刻的 UI</p></li><li><p>更新 React 元素：创建全新的元素，并传入 <code>ReactDOM.render()</code></p><ul><li>React 会自动检测需要更新的部分</li></ul></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><pre><code class="js">function Welcome(props){    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}const element = &lt;Welcome name="Sara" /&gt;;</code></pre><ul><li><p>组件：JavaScript 函数，或 ES6 Class</p></li><li><p>包括：</p><ul><li><p>入参 <code>props</code>（JSX 接收的属性和子组件） <strong>不可更改</strong>，由上级传递</p></li><li><p>状态 <code>state</code> 可变，私有，完全受控于自己（封装的） - 仅 class 组件</p></li></ul></li><li><p>组件可以进行组合嵌套（一般顶层组件是 <code>App</code> 组件）</p></li><li><p>命名 <code>props</code>：尽量以组件自身角度命名，不依赖调用上下文</p></li><li><p>生命周期：</p><ul><li><p>挂载（第一次被渲染到 DOM）：<code>componentDidMount()</code></p></li><li><p>卸载（从 DOM 中删除）：<code>componentWillUnmount()</code></p></li></ul></li><li><p>Class 可以随意添加不参与数据流的额外字段（比如计时器）</p></li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ul><li><p>直接修改 State 不会重新渲染组件，使用 <code>setState()</code></p></li><li><p>在 <code>setState()</code> 中不要依赖 <code>this.state</code> 和 <code>this.prop</code>，这两者可能会异步更新</p><ul><li>正确实践：传入函数 (state, props) =&gt; (newState)`</li></ul></li><li><p>State 与数据流：</p><ul><li><p>数据流沿组件树，通过 <code>props</code> 向下流动</p></li><li><p><code>state</code> 封装在某一组件中，并只能影响它下面的组件（通过 <code>props</code> 传递）</p></li></ul></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li><p>事件命名：<code>camelCase</code> 而非小写</p></li><li><p>传入一个函数体（不带括号调用！）</p></li><li><p>绑定 <code>this</code>：为了在回调（<code>this.handleClick</code>）中使用 <code>this</code>，需要在 <code>constructor()</code> 中显式绑定 <code>this</code></p><pre><code class="js">class Toggle extends React.Component{    constructor(props){        super(props);        this.state = {isToggledOn: true}        this.handleClick = this.handleClick.bind(this);    }    handleClick(){        this.setState(prevState =&gt; ({            isToggledOn: !prevState.isToggledOn        }));    }    render(){        return(            &lt;button onClick={this.handleClick}&gt;                {this.state.isToggleOn ? 'ON' : 'OFF'}            &lt;/button&gt;        );    }}</code></pre></li><li><p>或者：使用 <code>public class fields</code> 语法</p><pre><code class="js">handleClick = () =&gt; {    console.log('this is:', this);}</code></pre></li><li><p>或者：使用箭头函数</p><pre><code class="js">&lt;button onClick={() =&gt; {this.handleClick()}}&gt;    {this.state.isToggleOn ? 'ON' : 'OFF'}&lt;/button&gt;</code></pre></li><li><p>传递参数：待查</p></li></ul><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul><li><p>思路：把 React 元素当成一等 JavaScript 对象处理，采取元素变量、<code>if</code> 等方式</p></li><li><p>与运算符：<code>condition &amp;&amp; someElement</code></p></li><li><p>三目运算符</p></li></ul><h2 id="列表与-Key"><a href="#列表与-Key" class="headerlink" title="列表与 Key"></a>列表与 Key</h2><ul><li><p>数组可以用来渲染多个组件，比如列表：</p><pre><code class="js">function Item(props) {  return &lt;li&gt;Item {props.id}&lt;/li&gt;;}function List(props) {  const list = props.numbers.map((number) =&gt; &lt;Item key={number.toString()} id={number} /&gt;);  return &lt;ul&gt;{list}&lt;/ul&gt;;}const numbers = [0, 1, 2, 3, 4];function App(props) {  return &lt;List numbers={numbers}/&gt;;}ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</code></pre></li><li><p>列表兄弟项目之间使用唯一的 <code>key</code>（字符串）作为区分。</p></li><li><p><code>key</code> 的最佳实践：在<strong>数组就近的上下文</strong>中赋值，例如，列表组件而非列表项组件</p></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><ul><li><p>表单和 HTML 表单的不同点：</p><ul><li><p>HTML 中的表单是默认双向绑定的</p></li><li><p>在 React 中，需要手动绑定创建 “受控组件”</p></li></ul></li><li><p>受控组件（手动双向绑定）</p><pre><code class="js">class NameInput extends React.Component {  constructor(props) {    super(props);    this.state = {      value: "",    };    this.onValueChange = this.onValueChange.bind(this); // 绑定 this  }  onValueChange(e) {    this.setState({      value: e.target.value, // Input -&gt; State    });  }  render() {    return (      &lt;input        type="text"        value={this.state.value} // State -&gt; Input        onChange={this.onValueChange}      /&gt;    );  }}</code></pre></li></ul><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><blockquote><p>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的 “状态提升”。</p></blockquote><ul><li><p>提升后，原子组件的 <code>state</code> 移动到父组件的 <code>state</code> 中，子组件从父组件得到 <code>props</code></p></li><li><p>提升状态后，子组件无法直接修改父组件的 <code>state</code>，可以借助 “受控组件” 思路</p></li><li><p>子组件传入来自父组件的（绑定了 <code>this</code> 的）回调函数进行修改</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
